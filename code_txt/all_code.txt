#include "map.h"
#include "monster.h"
#include <stdio.h>

#define MIN_ROOM_SIZE  6
#define MAX_ROOM_SIZE  9
#define BOSS_ROOM_W    12  // ë§µ í¬ê¸°(40x40) ëŒ€ë¹„ ë„ˆë¬´ í¬ì§€ ì•Šê²Œ ì¡°ì •
#define BOSS_ROOM_H    9
#define ROOM_MARGIN    5   // ë°© ì‚¬ì´ì˜ ìµœì†Œ ê°„ê²©

int g_dungeon_map[MAP_HEIGHT][MAP_WIDTH];

// ê¸¸ ìƒì„± í•¨ìˆ˜: ë²½ë§Œ ê³¨ë¼ì„œ ëš«ì–´ ë¶ˆí•„ìš”í•œ ê´€í†µ ìµœì†Œí™”
void connect_points(int x1, int y1, int x2, int y2)
{
    int cx = x1;
    int cy = y1;

    // ê°€ë¡œ ì´ë™
    while (cx != x2)
    {
        // ë²½ì¼ ë•Œë§Œ ê¸¸(TILE_PATH)ë¡œ ë³€ê²½í•˜ì—¬ ê¸°ì¡´ ë°©/ë³´ìŠ¤ë°© íƒ€ì¼ ë³´í˜¸
        if (g_dungeon_map[cy][cx] == TILE_WALL) 
        {
            g_dungeon_map[cy][cx] = TILE_PATH;
        }
        cx += (x1 < x2) ? 1 : -1;
    }
    // ì„¸ë¡œ ì´ë™
    while (cy != y2)
    {
        if (g_dungeon_map[cy][cx] == TILE_WALL) 
        {
            g_dungeon_map[cy][cx] = TILE_PATH;
        }
        cy += (y1 < y2) ? 1 : -1;
    }
}

void init_map(int difficulty, int current_floor, int max_floor, Character *player)
{
    // 1. ë§µ ì „ì²´ ì´ˆê¸°í™”
    for (int y = 0; y < MAP_HEIGHT; y++)
        for (int x = 0; x < MAP_WIDTH; x++)
            g_dungeon_map[y][x] = TILE_WALL;

    int room_limit = 4 + difficulty; 
    Room rooms[10];
    int actual_rooms = 0;

    // 2. ë°© ìƒì„± ë£¨í”„
    for (int i = 0; i < room_limit; i++)
    {
        Room r;
        // ë§ˆì§€ë§‰ ë°©ì€ ë³´ìŠ¤ë°©ìœ¼ë¡œ ì„¤ì •
        if (current_floor == max_floor && i == room_limit - 1)
        {
            r.w = BOSS_ROOM_W; r.h = BOSS_ROOM_H;
        }
        else
        {
            r.w = GET_RAND(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
            r.h = GET_RAND(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
        }

        int is_overlap;
        int tries = 0;
        
        do {
            is_overlap = 0;
            r.x = GET_RAND(2, MAP_WIDTH - r.w - 2);
            r.y = GET_RAND(2, MAP_HEIGHT - r.h - 2);

            // ROOM_MARGINì„ ì ìš©í•´ ë°© ì‚¬ì´ ê±°ë¦¬ë¥¼ ê°•ì œí•¨
            for (int j = 0; j < actual_rooms; j++)
            {
                if (!(r.x + r.w + ROOM_MARGIN < rooms[j].x || r.x > rooms[j].x + rooms[j].w + ROOM_MARGIN ||
                      r.y + r.h + ROOM_MARGIN < rooms[j].y || r.y > rooms[j].y + rooms[j].h + ROOM_MARGIN))
                {
                    is_overlap = 1;
                    break;
                }
            }
            tries++;
        } while (is_overlap && tries < 150);

        if (is_overlap) continue;

        // ë°© ë°”ë‹¥ ìƒì„±
        for (int py = r.y; py < r.y + r.h; py++)
            for (int px = r.x; px < r.x + r.w; px++)
                g_dungeon_map[py][px] = TILE_PATH;

        rooms[actual_rooms] = r;

        // [í•µì‹¬] ì´ì „ ë°©ê³¼ í˜„ì¬ ë°©ì„ ì¼ëŒ€ì¼ë¡œë§Œ ì—°ê²° (ë°©-ê¸¸-ë°© êµ¬ì¡°)
        if (actual_rooms > 0)
        {
            connect_points(rooms[actual_rooms - 1].x + rooms[actual_rooms - 1].w / 2,
                           rooms[actual_rooms - 1].y + rooms[actual_rooms - 1].h / 2,
                           r.x + r.w / 2, r.y + r.h / 2);
        }
        actual_rooms++;
    }

    // 3. í”Œë ˆì´ì–´ ë° ë³´ìŠ¤/ê³„ë‹¨ ë°°ì¹˜
    if (actual_rooms > 0)
    {
        // ì‹œì‘ ìœ„ì¹˜: ì²« ë²ˆì§¸ ë°©
        player->x = rooms[0].x + rooms[0].w / 2;
        player->y = rooms[0].y + rooms[0].h / 2;

        // íƒˆì¶œêµ¬/ë³´ìŠ¤ ìœ„ì¹˜: ë§ˆì§€ë§‰ ë°©
        Room last = rooms[actual_rooms - 1];
        int tx = last.x + last.w / 2;
        int ty = last.y + last.h / 2;
        g_dungeon_map[ty][tx] = (current_floor == max_floor) ? TILE_BOSS : TILE_STAIRS;

        // ëª¬ìŠ¤í„° ìƒì„±
        spawn_monsters_in_rooms(rooms, actual_rooms, difficulty, (current_floor == max_floor));
    }

    printf("[ì‹œìŠ¤í…œ] %dì¸µ ë˜ì „ ìƒì„± ì™„ë£Œ (ë°©: %dê°œ)\n", current_floor, actual_rooms);
}
#ifndef MAP_H
#define MAP_H

#include "common.h"

#define MAP_WIDTH  40
#define MAP_HEIGHT 40


#define TILE_WALL    0
#define TILE_PATH    1
#define TILE_MONSTER 2
#define TILE_BOSS    3
#define TILE_CHEST   4
#define TILE_STAIRS  5


// ëª¬ìŠ¤í„° ì´ë™ë²”ìœ„ ì œí•œì„ ìœ„í•œ ë§µ êµ¬ì¡°ì²´
typedef struct
{
    int x, y, w, h;
} Room;

extern int g_dungeon_map[MAP_HEIGHT][MAP_WIDTH];


void init_map(int difficulty, int current_floor, int max_floor, Character *player);

#endif


#ifndef COMMON_H
#define COMMON_H

#include <SDL2/SDL.h>
#include <stdlib.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_image.h>
//í‚¤ ë§¤í¬ë¡œ ì •ë¦¬
#define KEY e.key.keysym.sym
#define SET_COLOR(r,g,b) SDL_SetRenderDrawColor(renderer, r, g, b, 255)
#define FILL_RECT(rect) SDL_RenderFillRect(renderer, &rect)
#define GET_RAND(min, max) (rand() % (max - min + 1 ) + min)

//ë§µ íƒ€ì¼ ì¢…ë¥˜ ì •ì˜
#define TILE_WALL 0
#define TILE_PATH 1
#define TILE_MONSTER 2
#define TILE_BOSS 3

// ê²Œì„ ìƒíƒœ ì •ì˜
#define STATE_MAIN_MENU 0
#define STATE_SELECT_JOB 1
#define STATE_SELECT_DIFF 2
#define STATE_MAP 99      // ë˜ì „ íƒí—˜
#define STATE_BATTLE 3    // ì „íˆ¬
#define STATE_GAME_OVER 7 // ê²°ê³¼


typedef struct
{
    int hp;
    int max_hp;
    int mp;
    int max_mp;
    int atk;
    int is_defending;

    int x;
    int y;

    int pixel_x;
    int pixel_y;
    int is_moving;

    /* ì• ë‹ˆë©”ì´ì…˜ ë° ë°©í–¥ */
    int dir;
    int anim_frame;
    int anim_timer;
} Character;

extern TTF_Font* g_font;

#endif

#include "monster.h"
#include <stdio.h>

Enemy g_monsters[MAX_MONSTERS];
int g_monster_count = 0;


void spawn_monsters_in_rooms(Room* rooms, int room_count, int difficulty, int is_boss_floor)
{
    g_monster_count = 0;

    for (int i = 1; i < room_count; i++)
    {
        /* ë§ˆì§€ë§‰ ë°©ì— ë³´ìŠ¤ ë°°ì¹˜ */
        if (is_boss_floor && i == room_count - 1)
        {
            Enemy* boss = &g_monsters[g_monster_count++];
            sprintf(boss->name, "Demon Boss");
            boss->hp = 150; boss->max_hp = 150; boss->atk = 15;
            boss->x = rooms[i].x + rooms[i].w / 2;
            boss->y = rooms[i].y + rooms[i].h / 2;
            boss->is_alive = 1;
            boss->ignore_turns = 0;
            g_dungeon_map[boss->y][boss->x] = TILE_BOSS;
            continue;
        }

        /* ì¼ë°˜ ëª¬ìŠ¤í„° ë°°ì¹˜ */
        if (g_monster_count < MAX_MONSTERS)
        {
            Enemy* e = &g_monsters[g_monster_count++];
            
            /* ë‚œì´ë„ë³„ ì´ë¦„ ì„¤ì • */
            if (difficulty == 0) sprintf(e->name, "Slime");
            else if (difficulty == 1) sprintf(e->name, "Bat");
            else sprintf(e->name, "Ghost");

            e->hp = 30; e->max_hp = 30; e->atk = 5;
            e->x = GET_RAND(rooms[i].x, rooms[i].x + rooms[i].w - 1);
            e->y = GET_RAND(rooms[i].y, rooms[i].y + rooms[i].h - 1);
            e->is_alive = 1;
            e->ignore_turns = 0;
            g_dungeon_map[e->y][e->x] = TILE_MONSTER;
        }
    }
}

// [ì¶”ê°€] ëª¨ë“  ëª¬ìŠ¤í„°ì˜ AIë¥¼ í•œ ë²ˆì— ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜ (í”Œë ˆì´ì–´ê°€ ì›€ì§ì¼ ë•Œ í˜¸ì¶œ)
void update_all_monsters_ai(int player_x, int player_y)
{
    for (int i = 0; i < g_monster_count; i++)
    {
        Enemy* e = &g_monsters[i];
        if (!e->is_alive || g_dungeon_map[e->y][e->x] == TILE_BOSS) continue; // ë³´ìŠ¤ëŠ” ì¼ë‹¨ ëŒ€ê¸°
	
	if (e->ignore_turns > 0)
	{
		e->ignore_turns--;
		continue;
	}

        int dx = abs(e->x - player_x);
        int dy = abs(e->y - player_y);
        int nx = e->x, ny = e->y;

        // ì¶”ê²© (ê±°ë¦¬ 6 ì´í•˜) -> ( 3ìœ¼ë¡œ ë³€ê²½)
        if (player_x >= e->min_x && player_x <= e->max_x && player_y >= e->min_y && player_y <= e->max_y && (dx + dy <= 3))
        {
            if (e->x < player_x) nx++; else if (e->x > player_x) nx--;
            else if (e->y < player_y) ny++; else if (e->y > player_y) ny--;
        }
        else // ë°°íšŒ
        {
            int dir = GET_RAND(0, 4);
            if (dir == 0) ny--; else if (dir == 1) ny++;
            else if (dir == 2) nx--; else if (dir == 3) nx++;
        }

        // ì´ë™ ê°€ëŠ¥ì„± ê²€ì¦ ë° ë§µ ë°˜ì˜
        if (nx >= e->min_x && nx <= e->max_x && ny >= e->min_y && ny <= e->max_y)
        {
            if (g_dungeon_map[ny][nx] == TILE_PATH)
            {
                g_dungeon_map[e->y][e->x] = TILE_PATH; // ì˜ˆì „ ìë¦¬ ì§€ìš°ê¸°
                e->x = nx; e->y = ny;
                g_dungeon_map[e->y][e->x] = TILE_MONSTER; // ìƒˆ ìë¦¬ ê·¸ë¦¬ê¸°
            }
        }
    }
}

void free_enemy(Enemy *target)
	{
		if (target != NULL)
		{
			printf("[ì‹œìŠ¤í…œ] ëª¬ìŠ¤í„° '%s' ë©”ëª¨ë¦¬ í•´ì œ\n", target ->name);
			free(target);
		}
	}

#ifndef MONSTER_H
#define MONSTER_H

#include "common.h"
#include "map.h"

typedef struct
{
    char name[20];
    int hp, max_hp, atk;
    int x, y;
    int min_x, max_x; // ëª¬ìŠ¤í„° í™œë™ êµ¬ì—­ (ë°© ê²½ê³„)
    int min_y, max_y;
    int is_alive;
    int ignore_turns;
} Enemy;

#define MAX_MONSTERS 30
extern Enemy g_monsters[MAX_MONSTERS];
extern int g_monster_count;

void spawn_monsters_in_rooms(Room* rooms, int room_count, int difficulty, int is_boss_floor);
void update_all_monsters_ai(int player_x, int player_y);
void free_enemy(Enemy *target);

//Enemy *create_enemy(char *name, int hp, int atk);
//void free_enemy(Enemy *target);


#endif
#include "ui.h"
#include <SDL2/SDL_ttf.h>
#include <stdio.h>

#define DW1_COLOR_BLACK 0, 0, 0, 255
#define DW1_COLOR_WHITE 255, 255, 255, 255
#define VISION_RADIUS_TORCH 2

/* ì „ì—­ í°íŠ¸ í¬ì¸í„° (main.cì—ì„œ ì´ˆê¸°í™”ë¨) */
extern TTF_Font* g_font;

/* ì´ë¯¸ì§€ íŒŒì¼ì„ SDL_Textureë¡œ ë³€í™˜í•˜ì—¬ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜ */
SDL_Texture* load_ui_texture(SDL_Renderer* renderer, const char* file_path)
{
    SDL_Texture* texture = IMG_LoadTexture(renderer, file_path);
    if (texture == NULL)
    {
        printf("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: %s, ì—ëŸ¬: %s\n", file_path, IMG_GetError());
    }
    return texture;
}

/* ìƒ‰ìƒ ì„¤ì •ì„ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ */
void set_color(SDL_Renderer* renderer, int r, int g, int b)
{
    SDL_SetRenderDrawColor(renderer, r, g, b, 255);
}

/* ì‚¬ê°í˜•ì„ ì±„ìš°ëŠ” í—¬í¼ í•¨ìˆ˜ */
void fill_rect(SDL_Renderer* renderer, SDL_Rect rect)
{
    SDL_RenderFillRect(renderer, &rect);
}

/* í…ìŠ¤íŠ¸ ë Œë”ë§ í•¨ìˆ˜: SDL_ttfë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ì •ëœ ì¢Œí‘œì— ì¶œë ¥ */
void render_text(SDL_Renderer* renderer, const char* text, int x, int y, int r, int g, int b)
{
    if (g_font == NULL || text == NULL)
    {
        return;
    }

    SDL_Color color = { (Uint8)r, (Uint8)g, (Uint8)b, 255 };
    
    /* ë ˆíŠ¸ë¡œ ê°ì„±ì„ ìœ„í•´ Solid ëª¨ë“œë¡œ ë Œë”ë§ */
    SDL_Surface* surface = TTF_RenderText_Solid(g_font, text, color);
    if (surface == NULL)
    {
        return;
    }

    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_Rect dst = { x, y, surface->w, surface->h };

    SDL_RenderCopy(renderer, texture, NULL, &dst);

    /* ë¦¬ì†ŒìŠ¤ í•´ì œ */
    SDL_FreeSurface(surface);
    SDL_DestroyTexture(texture);
}

void draw_dw_window(SDL_Renderer* renderer, int x, int y, int w, int h)
{
    SDL_Rect bg_rect;
    bg_rect.x = x; bg_rect.y = y; bg_rect.w = w; bg_rect.h = h;
    SDL_SetRenderDrawColor(renderer, DW1_COLOR_BLACK);
    SDL_RenderFillRect(renderer, &bg_rect);

    SDL_Rect outer_rect;
    outer_rect.x = x; outer_rect.y = y; outer_rect.w = w; outer_rect.h = h;
    SDL_SetRenderDrawColor(renderer, DW1_COLOR_WHITE);
    SDL_RenderDrawRect(renderer, &outer_rect);

    SDL_Rect inner_rect;
    inner_rect.x = x + 3; inner_rect.y = y + 3;
    inner_rect.w = w - 6; inner_rect.h = h - 6;
    SDL_RenderDrawRect(renderer, &inner_rect);
}

void render_dungeon_state(SDL_Renderer* renderer, int player_x, int player_y)
{
    /* í™”ë©´ ì „ì²´ë¥¼ ë“œí€˜ ë˜ì „ íŠ¹ìœ ì˜ ì¹ í‘ ê°™ì€ ì–´ë‘ ìœ¼ë¡œ ì´ˆê¸°í™” */
    SDL_SetRenderDrawColor(renderer, DW1_COLOR_BLACK);
    SDL_RenderClear(renderer);


    /* 1. ì»¤ë§¨ë“œ ìœˆë„ìš° (ì™¼ìª½ ìƒë‹¨ ì°°ì¹µ: COMMAND) */
    draw_dw_window(renderer, 30, 30, 200, 260);

    /* 2. ìŠ¤í…Œì´í„°ìŠ¤ ìœˆë„ìš° (ì˜¤ë¥¸ìª½ ìƒë‹¨ ì°°ì¹µ: NAME, HP, MP, LV, G, E) */
    draw_dw_window(renderer, 550, 30, 220, 200);

    /* 3. ë©”ì‹œì§€ ìœˆë„ìš° (í•˜ë‹¨ ì°°ì¹µ: ëŒ€í™” ë° ì „íˆ¬ ë¡œê·¸) */
    draw_dw_window(renderer, 100, 420, 600, 150);

    SDL_RenderPresent(renderer);
}

/* ë‚˜ì¤‘ì— Tiny 16 Basic ê°™ì€ íƒ€ì¼ì…‹ ì…í ë•Œ ì“¸ íƒ€ì¼ ë Œë”ëŸ¬ */
void draw_tile(SDL_Renderer* renderer, SDL_Texture* tileset, int tile_x, int tile_y, int screen_x, int screen_y, int size)
{
    if (tileset == NULL)
    {
        return;
    }
    SDL_Rect src;
    src.x = tile_x; src.y = tile_y; src.w = 16; src.h = 16;
    SDL_Rect dst;
    dst.x = screen_x; dst.y = screen_y; dst.w = size; dst.h = size;
    SDL_RenderCopy(renderer, tileset, &src, &dst);
}

void draw_scanlines(SDL_Renderer* renderer, int screen_width, int screen_height)
{
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 80);
    for (int y = 0; y < screen_height; y += 2)
    {
        SDL_RenderDrawLine(renderer, 0, y, screen_width - 1, y);
    }
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
}


void play_encounter_transition(SDL_Renderer* renderer)
{
    int w = 800;
    int h = 600;
    int step = 40; /* 8ë¹„íŠ¸ íŠ¹ìœ ì˜ íˆ¬ë°•í•œ íƒ€ì¼ ëŠë‚Œì„ ë‚´ê¸° ìœ„í•œ ë¸”ë¡ ë‘ê»˜ */

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    /* í™”ë©´ ë°”ê¹¥ìª½ í…Œë‘ë¦¬ë¶€í„° ì¤‘ì‹¬ë¶€ê¹Œì§€ ì‚¬ê°í˜•ì„ ê·¸ë¦¬ë©° ì¢í˜€ ë“¤ì–´ê° */
    for (int i = 0; i < w / 2; i += step)
    {
        /* 1. ìƒë‹¨ ê°€ë¡œì¤„ ë®ê¸° */
        SDL_Rect top = { i, i, w - 2 * i, step };
        SDL_RenderFillRect(renderer, &top);
        SDL_RenderPresent(renderer);
        SDL_Delay(15); /* íšŒì˜¤ë¦¬ì¹˜ëŠ” ì†ë„ ì¡°ì ˆ (ë„ˆë¬´ ë¹ ë¥´ë©´ ìˆ«ìë¥¼ ëŠ˜ë¦´ ê²ƒ) */

        /* 2. ìš°ì¸¡ ì„¸ë¡œì¤„ ë®ê¸° */
        SDL_Rect right = { w - i - step, i + step, step, h - 2 * i - 2 * step };
        SDL_RenderFillRect(renderer, &right);
        SDL_RenderPresent(renderer);
        SDL_Delay(15);

        /* 3. í•˜ë‹¨ ê°€ë¡œì¤„ ë®ê¸° */
        SDL_Rect bottom = { i, h - i - step, w - 2 * i, step };
        SDL_RenderFillRect(renderer, &bottom);
        SDL_RenderPresent(renderer);
        SDL_Delay(15);

        /* 4. ì¢Œì¸¡ ì„¸ë¡œì¤„ ë®ê¸° */
        SDL_Rect left = { i, i + step, step, h - 2 * i - 2 * step };
        SDL_RenderFillRect(renderer, &left);
        SDL_RenderPresent(renderer);
        SDL_Delay(15);
    }
}
#ifndef UI_H
#define UI_H

#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

/* ì´ë¯¸ì§€ íŒŒì¼ì„ í…ìŠ¤ì²˜ë¡œ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜ */
SDL_Texture* load_ui_texture(SDL_Renderer* renderer, const char* file_path);

/* ë“œë˜ê³¤ ì›Œë¦¬ì–´ ìŠ¤íƒ€ì¼ ìœˆë„ìš° ë° í…ìŠ¤íŠ¸ í•¨ìˆ˜ ì„ ì–¸ */
void draw_dw_window(SDL_Renderer* renderer, int x, int y, int w, int h);
void render_text(SDL_Renderer* renderer, const char* text, int x, int y, int r, int g, int b);
void draw_tile(SDL_Renderer* renderer, SDL_Texture* tileset, int tile_x, int tile_y, int screen_x, int screen_y, int size);
void set_color(SDL_Renderer* renderer, int r, int g, int b);
void fill_rect(SDL_Renderer* renderer, SDL_Rect rect);
void play_encounter_transition(SDL_Renderer* renderer);

void draw_scanlines(SDL_Renderer* renderer, int screen_width, int screen_height);


#endif
#include <SDL2/SDL.h>		//SDL2 í—¤ë” íŒŒì¼
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_image.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include "monster.h"
#include "map.h"
#include "ui.h"
#include "common.h"


TTF_Font* g_font = NULL;
SDL_Texture* map_tex = NULL;
SDL_Texture* char_tex = NULL;
SDL_Texture* tileset_tex = NULL;

#define KEY e.key.keysym.sym	//75ì¤„
#define SET_COLOR(r,g,b) SDL_SetRenderDrawColor(renderer, r, g, b, 255)
#define FILL_RECT(rect) SDL_RenderFillRect(renderer, &rect)
#define GET_RAND(min, max) (rand() % (max - min + 1 ) + min) 	//ëœë¤ ë‚œìˆ˜ ë²”ìœ„ êµ¬í˜„

//ë‚œì´ë„ ì„¤ì • ì „ì—­ ë³€ìˆ˜
char *diff_names[] = {"Slime Forest", "Goblin Cave", "Demon Castle"};
//ì „íˆ¬ ì‹œ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ë‰´ ë‚˜ì—´
char *battle_menu[] = {"Attack", "Skill", "Item", "Defense", "Run"};
//
char *warrior_skills[] = {"PowerStrike", "Whirlwind"};		//íœ ì´ ì•„ë‹Œ í›¨ìœˆë“œì´ë‹¤.
char *mage_skills[] = 	{"MagicArrow", "Meteor"};		
char *item_menu[] = {"HP Potion", "MP Potion"};

char **current_skills; 					 	//ë”ë¸” í¬ì¸í„°ë¡œ ì§ì—… ìŠ¤í‚¬ ì—°ê²°

int saved_map_x = 0;						//ì „íˆ¬ í›„ ë³µê·€ë¥¼ ìœ„í•œ ì¢Œí‘œ
int saved_map_y = 0;


int main(int argc, char *argv[])
{	
	//ë°°ì—´ í¬ê¸° ë³€ìˆ˜ ì„¤ì •
	int diff_count = sizeof(diff_names) / sizeof(diff_names[0]);
	int current_skill_count = 0;
	int battle_menu_count = sizeof(battle_menu) / sizeof(battle_menu[0]);
	int item_menu_count = sizeof(item_menu) / sizeof(item_menu[0]);
	srand(time(NULL));

	int difficulty = 0;
	int hp_potions = 2;
	int mp_potions = 2;
	int current_floor = 1;
	int max_floor = 3;	

	//ì‹œìŠ¤í…œ ì´ˆê¸°í™” í›„ ë¶€íŒ… í™•ì¸ ì—¬ë¶€ íŒë‹¨
	if (SDL_Init(SDL_INIT_VIDEO) < 0){				//ì‹œìŠ¤í…œ ì—ëŸ¬ í™•ì¸
		printf("ì´ˆê¸°í™” ì‹¤íŒ¨ ì—ëŸ¬ë‚´ìš©: %s\n", SDL_GetError());	//ì—ëŸ¬ ì´ìœ  ì¶œë ¥
		return 1;
	}

	if (TTF_Init() == -1) {
		printf("í°íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨: %s\n", TTF_GetError());
		return 1;
	}

	g_font = TTF_OpenFont("dq_font.ttf", 24);
	if (g_font == NULL)
	{
		/* íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ ì¶œë ¥ í›„ ì¢…ë£Œ ë°©ì§€ ë˜ëŠ” ì²˜ë¦¬ */
		printf("í°íŠ¸ ë¡œë“œ ì‹¤íŒ¨ (dq_font.ttf): %s\n", TTF_GetError());
	}

	//ìœˆë„ìš° ì°½ ìƒì„± ì„¤ì •	
	SDL_Window *window = SDL_CreateWindow(
			"RPG Project",			//ì°½ ì œëª©
			SDL_WINDOWPOS_CENTERED,		//ì°½ ê°€ë¡œ í¬ê¸°
			SDL_WINDOWPOS_CENTERED,		//ì°½ ì„¸ë¡œ í¬ê¸°
			800, 600,			
			SDL_WINDOW_SHOWN 		
			);

	//ìœˆë„ìš° ì°½ ìƒì„± ì„±ê³µ ì—¬ë¶€ ê´€ë ¨ ì½”ë“œ
	if (window == NULL)
	{
		printf("ìœˆë„ìš° ìƒì„± ì‹¤íŒ¨ ì—ëŸ¬ë‚´ìš©: %s\n",SDL_GetError());
		SDL_Quit();
		return 1;
	}

	//ì‹œìŠ¤í…œ ë Œë” ìƒì„±
	SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

	map_tex = IMG_LoadTexture(renderer, "map_tiles.png");
	char_tex = IMG_LoadTexture(renderer, "master_tiles.png");

	if (map_tex == NULL || char_tex == NULL)
	{
		printf("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨\n");
		return 1;
	}

	SDL_SetTextureBlendMode(map_tex, SDL_BLENDMODE_BLEND);
	SDL_SetTextureBlendMode(char_tex, SDL_BLENDMODE_BLEND);

	SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

	//ì‚¬ìš©ì ì •ì˜ ë³€ìˆ˜
	int menu_index = 0;	//**ì•„ë§ˆ 0,1 ë¡œ ê²Œì„ ì‹œì‘ê³¼ ì¢…ë£Œë¥¼ í•´ë‘˜ ì˜ˆì •
	int game_state = 0;
	int is_boss = 0;

	//ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë£¨í”„ ëª…ë ¹ì–´
	int quit = 0;
	SDL_Event e;

	//ì‚¬ìš©ì ì •ì˜ ë°ì´í„°(ìºë¦­í„°)
	Character warrior = {150, 150, 30, 30, 20, 0, 0, 0};	//ì²´ë ¥,ìµœëŒ€ì²´ë ¥,ë§ˆë‚˜,ìµœëŒ€ë§ˆë‚˜,ê³µê²©ë ¥
								//
	Character mage = {80, 80, 120, 120, 10, 0, 0, 0};
	Character player;				//ì‹¤ì œ í”Œë ˆì´ì–´ ë°ì´í„° ì„¤ì •

	Enemy *current_monster = NULL; 			//ë™ì í• ë‹¹ìœ¼ë¡œ ë³€ê²½(2026-02-13)

	while(!quit)
	{

		if (game_state == 99)
		{
			player.anim_timer++;
			if (player.anim_timer > 12)
			{
				player.anim_frame = !player.anim_frame;
				player.anim_timer = 0;
			}

			if (player.is_moving)
			{
				int target_px = player.x * 48;
				int target_py = player.y * 48;
				int move_speed = 4;

				if (player.pixel_x < target_px) player.pixel_x += move_speed;
				else if (player.pixel_x > target_px) player.pixel_x -= move_speed;

				if (player.pixel_y < target_py) player.pixel_y += move_speed;
				else if (player.pixel_y > target_py) player.pixel_y -= move_speed;

				if (player.pixel_x == target_px && player.pixel_y == target_py)
				{
					player.is_moving = 0;
					update_all_monsters_ai(player.x, player.y);

					if (g_dungeon_map[player.y][player.x] == TILE_STAIRS)
					{
						current_floor++;
						init_map(difficulty, current_floor, max_floor, &player);
						player.pixel_x = player.x * 48;
						player.pixel_y = player.y * 48;
					}
				}
			}
		}

		while (SDL_PollEvent(&e) != 0)
		{
			if (e.type == SDL_QUIT)
			{
				quit = 1;
			}
			else if (e.type == SDL_KEYDOWN)
			{

				if (KEY == SDLK_ESCAPE)
				{
					// ìŠ¤í‚¬(4), ì•„ì´í…œ(5), ë„ë§(6) ë©”ë‰´ì¼ ë•ŒëŠ” ì „íˆ¬ ë©”ì¸(3)ìœ¼ë¡œ ë³µê·€
					if (game_state == 4 || game_state == 5 || game_state == 6)
					{
						if (game_state == 4) menu_index = 1;      // ìŠ¤í‚¬ ë©”ë‰´ì˜€ìœ¼ë©´ ìŠ¤í‚¬ ì¹¸ìœ¼ë¡œ
						else if (game_state == 5) menu_index = 2; // ì•„ì´í…œ ë©”ë‰´ì˜€ìœ¼ë©´ ì•„ì´í…œ ì¹¸ìœ¼ë¡œ
						else if (game_state == 6) menu_index = 4; // ë„ë§ ë©”ë‰´ì˜€ìœ¼ë©´ ë„ë§ ì¹¸ìœ¼ë¡œ
						game_state = 3;
					}
					// ê·¸ ì™¸ ìƒíƒœ(ë§µ íƒí—˜, ì„ íƒì°½ ë“±)ì¼ ë•Œë§Œ ë©”ì¸í™”ë©´(0)ìœ¼ë¡œ íƒˆì¶œ
					else 
					{
						game_state = 0;
						menu_index = 0;
					}
					continue; // ESC ì²˜ë¦¬ê°€ ëë‚¬ìœ¼ë¯€ë¡œ ì•„ë˜ìª½ stateë³„ ì…ë ¥ ë¡œì§ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
				}	

				if (game_state == 0)
				{
					if (KEY == SDLK_UP) { menu_index = 0; }
					else if (KEY == SDLK_DOWN) { menu_index = 1; }
					else if (KEY == SDLK_RETURN)
					{
						if (menu_index == 0) { game_state = 1; menu_index = 0; }
						else { quit = 1; }
					}
				}
				else if (game_state == 1)
				{
					if (KEY == SDLK_LEFT) { menu_index = 0; }
					else if (KEY == SDLK_RIGHT) { menu_index = 1; }
					else if (KEY == SDLK_RETURN)
					{
						if (menu_index == 0)
						{
							player = warrior;
							current_skills = warrior_skills;
							current_skill_count = 2;
						}
						else
						{
							player = mage;
							current_skills = mage_skills;
							current_skill_count = 2;
						}
						game_state = 2; menu_index = 0;
					}	
				}
				else if (game_state == 2)
				{
					if (KEY == SDLK_UP) { if(menu_index > 0) menu_index--; }
					else if (KEY == SDLK_DOWN) { if(menu_index < diff_count -1) menu_index++; }
					else if (KEY == SDLK_RETURN)
					{
						difficulty = menu_index;
						//ë‚˜ê°€ê±°ë‚˜ ë‹¤ì‹œ ì…ì¥ í•  ë•Œ ì²´ë ¥ ì´ˆê¸°í™” ë° í¬ì…˜ ë³´ì¶© ë¡œì§
						player.hp = player.max_hp;
						player.mp = player.max_mp;
						hp_potions = 2;
						mp_potions = 2;
						current_floor = 1;
						init_map(difficulty, current_floor, max_floor, &player);
						player.pixel_x = player.x * 48;
						player.pixel_y = player.y * 48;
						player.is_moving = 0;
						game_state = 99;
						menu_index = 0;
					}
				}

				else if (game_state == 99 && !player.is_moving)
				{
					int nx = player.x;
					int ny = player.y;
					int moved = 0;

					if (KEY == SDLK_UP) { ny--; player.dir = 3; moved = 1; }
					else if (KEY == SDLK_DOWN) { ny++; player.dir = 0; moved = 1; }
					else if (KEY == SDLK_LEFT) { nx--; player.dir = 1; moved = 1; }
					else if (KEY == SDLK_RIGHT) { nx++; player.dir = 2; moved = 1; }

					if (moved && nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT)
					{
						Enemy* target_mon = NULL;
						for (int i = 0; i < g_monster_count; i++)
						{
							if (g_monsters[i].is_alive && g_monsters[i].x == nx && g_monsters[i].y == ny)
							{
								target_mon = &g_monsters[i];
								break;
							}
						}

						if (target_mon != NULL)
						{
							if (target_mon->ignore_turns <= 0)
							{
								current_monster = target_mon;
								/* ğŸ’¡ ìˆ˜ì •ë¨: í”Œë ˆì´ì–´ ì¢Œí‘œê°€ ì•„ë‹Œ ì‹¤ì œ 'ëª¬ìŠ¤í„°ì˜ íƒ€ì¼ ì¢Œí‘œ(nx, ny)'ë¥¼ ì €ì¥! */
								saved_map_x = nx;  
								saved_map_y = ny;
								is_boss = (g_dungeon_map[ny][nx] == TILE_BOSS);
								game_state = 3; 
								menu_index = 0;
							}
						}
						else
						{
							int tile = g_dungeon_map[ny][nx];
							if (tile == TILE_PATH || tile == TILE_STAIRS)
							{
								player.x = nx; player.y = ny; player.is_moving = 1;
							}
						}
					}
				}	

				else if (game_state == 3)
				{
					if (KEY == SDLK_UP) { if(menu_index > 0) menu_index--; }
					else if (KEY == SDLK_DOWN) { if(menu_index < battle_menu_count - 1) menu_index++; }
					else if (KEY == SDLK_RETURN)
					{
						switch (menu_index)
						{
							case 0:
								{
									int final_dmg = GET_RAND(player.atk - 5, player.atk + 5);
									current_monster->hp -= final_dmg;
									printf("\n[ê³µê²©] %sì—ê²Œ %dì˜ ë°ë¯¸ì§€!\n", current_monster->name, final_dmg);

									if (current_monster->hp <= 0)
									{
										current_monster->hp = 0;
										printf("%së¥¼ ì²˜ì¹˜ í–ˆìŠµë‹ˆë‹¤! ì „íˆ¬ ìŠ¹ë¦¬!\n", current_monster->name);
										g_dungeon_map[saved_map_y][saved_map_x] = TILE_PATH;
										current_monster->is_alive = 0;
										current_monster = NULL;
										player.is_defending = 0;
										if (is_boss) game_state = 7;
										else game_state = 99;
									}
									else
									{	
										// ëª¬ìŠ¤í„° ë°˜ê²©
										int m_dmg = GET_RAND(current_monster->atk - 2, current_monster->atk + 2);
										if (player.is_defending)
										{
											m_dmg /= 2;
											printf("[ë°©ì–´ ì„±ê³µ] %sì˜ ê³µê²©ì„ ë§‰ì•„ëƒˆë‹¤! %dì˜ í”¼í•´!\n", current_monster->name, m_dmg);
											player.is_defending = 0; // ë°©ì–´ í•´ì œ
										}
										else
										{
											printf("%sì˜ ë°˜ê²©! %dì˜ í”¼í•´!\n", current_monster->name, m_dmg);
										}

										player.hp -= m_dmg;
										if (player.hp <= 0)
										{
											player.hp = 0;
											printf("ì „íˆ¬ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤...\n");
											game_state = 7;
										}
									}
									break;
								}
							case 1: game_state = 4; menu_index = 0; break;
							case 2: game_state = 5; menu_index = 0; break;
							case 3: 
								{
									player.is_defending = 1;
									printf("\n[ë°©ì–´] ë°©ì–´ íƒœì„¸! ëª¬ìŠ¤í„°ì˜ ê³µê²©ì„ ëŒ€ë¹„í•©ë‹ˆë‹¤.\n");

									// ë°©ì–´ ì¦‰ì‹œ ëª¬ìŠ¤í„°ê°€ ë•Œë¦¼ (í„´ ì†Œëª¨)
									int m_dmg = GET_RAND(current_monster->atk - 2, current_monster->atk + 2);
									m_dmg /= 2; // ë°©ì–´ ì¤‘ì´ë¯€ë¡œ ë¬´ì¡°ê±´ ë°ë¯¸ì§€ ë°˜ê°
									printf("[ë°©ì–´ ì„±ê³µ] %sì˜ ê³µê²©ì„ ë§‰ì•„ëƒˆë‹¤! %dì˜ í”¼í•´!\n", current_monster->name, m_dmg);
									player.hp -= m_dmg;
									player.is_defending = 0; // ë§ê³  ë‚˜ì„œ ë°©ì–´ í•´ì œ

									if (player.hp <= 0)
									{
										player.hp = 0;
										printf("ì „íˆ¬ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤...\n");
										game_state = 7;
									}
									break;
								}
							case 4: game_state = 6; menu_index = 0; break;
						}

					}
				}
				else if (game_state == 4) //ìŠ¤í‚¬ ì°½ ë¡œì§
				{
					if (KEY == SDLK_UP) { if(menu_index > 0) menu_index--; }
					else if (KEY == SDLK_DOWN) { if(menu_index < current_skill_count - 1) menu_index++; }

					else if (KEY == SDLK_RETURN)
					{
						int skill_dmg = 0;
						int mp_cost = 0;

						// ì „ì‚¬ ìŠ¤í‚¬ íŒì •
						if (current_skills == warrior_skills) 
						{
							mp_cost = 15;
							skill_dmg = player.atk * 2; // í‰íƒ€ 2ë°°
						}
						else // ë§ˆë²•ì‚¬ ìŠ¤í‚¬ íŒì •
						{
							mp_cost = 25;
							skill_dmg = player.atk * 3; // í‰íƒ€ 3ë°°
						}


						if (player.mp >= mp_cost)
						{
							player.mp -= mp_cost;
							current_monster->hp -= skill_dmg;
							printf("\n[ìŠ¤í‚¬] %s ë°œë™! %sì—ê²Œ %dì˜ í”¼í•´! (ì†Œëª¨ MP: %d)\n", current_skills[menu_index], current_monster->name, skill_dmg, mp_cost);

							if (current_monster->hp <= 0)
							{
								// 1. ëª¬ìŠ¤í„°ê°€ ì£½ì—ˆì„ ë•Œ (ë§µìœ¼ë¡œ ë³µê·€)
								current_monster->hp = 0;
								printf("%së¥¼ ì²˜ì¹˜ í–ˆìŠµë‹ˆë‹¤! ì „íˆ¬ ìŠ¹ë¦¬!\n", current_monster->name);
								g_dungeon_map[saved_map_y][saved_map_x] = TILE_PATH;
								current_monster->is_alive = 0;
								current_monster = NULL;
								player.is_defending = 0;
								if (is_boss) game_state = 7;
								else game_state = 99;
							}
							else
							{
								// ëª¬ìŠ¤í„°ê°€ ì‚´ì•„ì„œ ë°˜ê²©
								int m_dmg = GET_RAND(current_monster->atk - 2, current_monster->atk + 2);
								printf("%sì˜ ë°˜ê²©! %dì˜ í”¼í•´!\n", current_monster->name, m_dmg);
								player.hp -= m_dmg;

								if (player.hp <= 0)
								{
									// 2. í”Œë ˆì´ì–´ê°€ ì£½ì—ˆì„ ë•Œ (ê²Œì„ ì˜¤ë²„)
									player.hp = 0;
									printf("ì „íˆ¬ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤...\n");
									game_state = 7;
								}
								else
								{
									// 3. ë‘˜ ë‹¤ ì‚´ì•˜ì„ ë•Œë§Œ ì „íˆ¬ ë©”ì¸ìœ¼ë¡œ ë³µê·€
									game_state = 3;
								}
							}
							menu_index = 0;
						}						

						else
						{
							printf("\n[ì‹œìŠ¤í…œ] MPê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! (í˜„ì¬ MP: %d)\n", player.mp);
						}
					}					

					else if (KEY == SDLK_ESCAPE)
					{
						game_state = 3;
						menu_index = 1; // ESC ëˆ„ë¥´ë©´ ìŠ¤í‚¬ ì»¤ì„œë¡œ ëŒì•„ê°€ê¸°
					}
				}

				else if (game_state == 5) // ì•„ì´í…œ ì°½ ë¡œì§
				{
					if (KEY == SDLK_UP) { if(menu_index > 0) menu_index--; }
					else if (KEY == SDLK_DOWN) { if(menu_index < item_menu_count - 1) menu_index++; }
					else if (KEY == SDLK_RETURN)
					{
						int item_used = 0; // ì•„ì´í…œ ì‚¬ìš© ì—¬ë¶€ í”Œë˜ê·¸

						if (menu_index == 0) // HP í¬ì…˜
						{
							if (hp_potions > 0)
							{
								hp_potions--;
								player.hp += 50;
								if (player.hp > player.max_hp) player.hp = player.max_hp;
								printf("\n[ì•„ì´í…œ] HP í¬ì…˜ ì‚¬ìš©! (í˜„ì¬ HP: %d/%d) [ë‚¨ì€ ê°œìˆ˜: %d]\n", player.hp, player.max_hp, hp_potions);
								item_used = 1;
							}
							else { printf("\n[ì‹œìŠ¤í…œ] ë³´ìœ í•˜ì‹  HP í¬ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.\n"); }
						}
						else if (menu_index == 1) // MP í¬ì…˜
						{
							if(mp_potions > 0)
							{
								mp_potions--;
								player.mp += 30;
								if (player.mp > player.max_mp) player.mp = player.max_mp;
								printf("\n[ì•„ì´í…œ] MP í¬ì…˜ ì‚¬ìš©! (í˜„ì¬ MP: %d/%d) [ë‚¨ì€ ê°œìˆ˜: %d]\n", player.mp, player.max_mp, mp_potions);
								item_used = 1;
							}
							else { printf("\n[ì‹œìŠ¤í…œ] ë³´ìœ í•˜ì‹  MP í¬ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.\n"); }
						}

						// ì•„ì´í…œì„ ì¼ì„ ë•Œë§Œ ëª¬ìŠ¤í„°ê°€ ë•Œë¦¼ (í„´ ì†Œëª¨)
						if (item_used)
						{
							int m_dmg = GET_RAND(current_monster->atk - 2, current_monster->atk + 2);
							printf("%sì˜ ê³µê²©! %dì˜ í”¼í•´!\n", current_monster->name, m_dmg);
							player.hp -= m_dmg;

							if (player.hp <= 0)
							{
								player.hp = 0;
								printf("ì „íˆ¬ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤...\n");
								game_state = 7;
							}
							else { game_state = 3; } // ì „íˆ¬ ë©”ì¸ìœ¼ë¡œ ë³µê·€
						}
						menu_index = 0;
					}
					else if (KEY == SDLK_ESCAPE)
					{
						game_state = 3;
						menu_index = 2; // ESC ëˆ„ë¥´ë©´ ì•„ì´í…œ ì»¤ì„œë¡œ ëŒì•„ê°€ê¸°
					}
				}

				else if (game_state == 6)
				{
					if (KEY == SDLK_UP) { if(menu_index > 0) menu_index--; }
					else if (KEY == SDLK_DOWN) { if(menu_index < 1) menu_index++; }
					else if (KEY == SDLK_RETURN)
					{
						if(menu_index == 0) // "ì˜ˆ" ì„ íƒ ì‹œ ë„ë§
						{
							printf("ë¬´ì‚¬íˆ ë„ë§ì³¤ë‹¤!\n");

							// ë³´ìŠ¤ê°€ ì•„ë‹ ë•Œë§Œ ë¬´ì  ì‹œê°„ ë¶€ì—¬ (ë³´ìŠ¤ëŠ” ì¦‰ì‹œ ì¬ì¡°ìš° ê°€ëŠ¥í•˜ê²Œ)
							if (current_monster != NULL)
							{
								if (!is_boss) 
								{
									current_monster->ignore_turns = 5; 
								}
								else 
								{
									current_monster->ignore_turns = 0; // ë³´ìŠ¤ëŠ” ë¬´ì  ì—†ìŒ
								}
							}

							current_monster = NULL; // ì¡°ìš° ì¤‘ì¸ ëª¬ìŠ¤í„° ì •ë³´ ì´ˆê¸°í™”
							game_state = 99;        // ë˜ì „ìœ¼ë¡œ ë³µê·€
						} 
						else 
						{ 
							game_state = 3;         // "ì•„ë‹ˆì˜¤" ì„ íƒ ì‹œ ë‹¤ì‹œ ì „íˆ¬ ë©”ë‰´ë¡œ
						}
						menu_index = 0;
					}		
				}
				else if (game_state == 7)
				{
					if (KEY == SDLK_RETURN)
					{
						game_state = 0;
						menu_index = 0;
					}
				}
			}
		}

		/* í™”ë©´ ì´ˆê¸°í™” */
		SET_COLOR(0,0,0);
		SDL_RenderClear(renderer);          

		/* ë©”ì¸ ë©”ë‰´ (game_state == 0) */
		if (game_state == 0)
		{
			draw_dw_window(renderer, 150, 80, 500, 120);
			render_text(renderer, "RPG PROJECT", 285, 125, 255, 255, 255);

			draw_dw_window(renderer, 300, 300, 200, 120);

			if (menu_index == 0) render_text(renderer, "START", 360, 330, 255, 255, 0);
			else render_text(renderer, "START", 360, 330, 255, 255, 255);

			if (menu_index == 1) render_text(renderer, "EXIT", 360, 375, 255, 255, 0);
			else render_text(renderer, "EXIT", 360, 375, 255, 255, 255);

			int cursor_y = (menu_index == 0) ? 330 : 375;
			render_text(renderer, ">", 335, cursor_y, 255, 255, 0);
		}

		/* ìºë¦­í„° ì„ íƒ (game_state == 1) */
		else if (game_state == 1)
		{
			draw_dw_window(renderer, 30, 40, 740, 80);
			render_text(renderer, "CHOOSE THY PROFESSION", 170, 65, 255, 255, 255);

			draw_dw_window(renderer, 30, 140, 360, 280);
			if (menu_index == 0) 
			{
				render_text(renderer, ">", 50, 160, 255, 255, 0);
				render_text(renderer, "WARRIOR", 80, 160, 255, 255, 0);
			}
			else render_text(renderer, "WARRIOR", 80, 160, 255, 255, 255);

			render_text(renderer, "HP : 150", 80, 230, 200, 200, 200);
			render_text(renderer, "MP : 30", 80, 280, 200, 200, 200);
			render_text(renderer, "ATK: 20", 80, 330, 200, 200, 200);

			draw_dw_window(renderer, 410, 140, 360, 280);
			if (menu_index == 1) 
			{
				render_text(renderer, ">", 430, 160, 255, 255, 0);
				render_text(renderer, "MAGE", 460, 160, 255, 255, 0);
			}
			else render_text(renderer, "MAGE", 460, 160, 255, 255, 255);

			render_text(renderer, "HP : 80", 460, 230, 200, 200, 200);
			render_text(renderer, "MP : 120", 460, 280, 200, 200, 200);
			render_text(renderer, "ATK: 10", 460, 330, 200, 200, 200);

			draw_dw_window(renderer, 30, 440, 740, 130);
			if (menu_index == 0)
			{
				render_text(renderer, "STURDY OF BODY,SWIFT OF BLADE.", 50, 470, 255, 255, 255);
				render_text(renderer, "A TRUE CHAMPION FOR THEE.", 50, 515, 255, 255, 255);
			}
			else
			{
				render_text(renderer, "MASTER OF ANCIENT SPELLS.", 50, 470, 255, 255, 255);
				render_text(renderer, "FRAGILE, YET WISE IN MIND.", 50, 515, 255, 255, 255);
			}
		}

		else if (game_state == 2)
		{
			draw_dw_window(renderer, 100, 40, 600, 80);
			render_text(renderer, "WHITHER ART THOU BOUND?", 130, 65, 255, 255, 255);

			draw_dw_window(renderer, 180, 160, 440, 360);
			for (int i = 0; i < diff_count; i++)
			{
				if (menu_index == i) 
				{
					render_text(renderer, ">", 210, 210 + (i * 100), 255, 255, 0);
					render_text(renderer, diff_names[i], 250, 210 + (i * 100), 255, 255, 0);
				}
				else
				{
					render_text(renderer, diff_names[i], 250, 210 + (i * 100), 255, 255, 255);
				}
			}
		}

		else if (game_state == 99)
		{
			/* íƒ€ì¼ ì›ë³¸ í¬ê¸°(ts) ë° í™”ë©´ ì¶œë ¥ í¬ê¸°(ss) ì„¤ì • */
			int ts = 16;
			int ss = 48;
			int ox = (800 - (17 * ss)) / 2;
			int oy = (600 - (13 * ss)) / 2;

			for (int cy = 0; cy < 13; cy++)
			{
				for (int cx = 0; cx < 17; cx++)
				{
					int mx = player.x - 8 + cx;
					int my = player.y - 6 + cy;

					if (mx >= 0 && mx < MAP_WIDTH && my >= 0 && my < MAP_HEIGHT)
					{
						int t = g_dungeon_map[my][mx];
						SDL_Rect d_r = { ox + cx * ss, oy + cy * ss, ss, ss };

						/* 1. ë§µ íƒ€ì¼ ë Œë”ë§ (map_tiles.png ì‚¬ìš©) */
						if (t == TILE_WALL)
						{
							int sx = (difficulty == 0) ? 64 : ((difficulty == 1) ? 112 : 0);
							int sy = (difficulty == 0) ? 176 : ((difficulty == 1) ? 16 : 0);
							SDL_Rect s_r = { sx, sy, ts, ts };
							SDL_RenderCopy(renderer, map_tex, &s_r, &d_r);
						}
						else
						{
							int psx = (difficulty == 0) ? 16 : ((difficulty == 1) ? 32 : 16);
							int psy = (difficulty == 0) ? 128 : ((difficulty == 1) ? 144 : 0);
							SDL_Rect s_r = { psx, psy, ts, ts };
							SDL_RenderCopy(renderer, map_tex, &s_r, &d_r);

							if (t == TILE_STAIRS)
							{
								SDL_Rect stair_s = { 0, 112, ts, ts };
								SDL_RenderCopy(renderer, map_tex, &stair_s, &d_r);
							}
							else if (t == TILE_MONSTER || t == TILE_BOSS)
							{
								/* [ìˆ˜ì • í¬ì¸íŠ¸] ëª¬ìŠ¤í„° ë° ë³´ìŠ¤ ì¢Œí‘œ */
								int msx = 0; int msy = 0;
								if (t == TILE_BOSS) { msx = 96; msy = 64; }       /* ë³´ìŠ¤ */
								else if (difficulty == 0) { msx = 0; msy = 64; }  /* 1ë‹¨ê³„ ëª¹ */
								else if (difficulty == 1) { msx = 144; msy = 0; } /* 2ë‹¨ê³„ ëª¹ */
								else { msx = 48; msy = 64; }                       /* 3ë‹¨ê³„ ëª¹ */

								SDL_Rect m_s = { msx + (player.anim_frame * 16), msy, ts, ts };
								SDL_RenderCopy(renderer, char_tex, &m_s, &d_r);
							}
						}
					}
				}
			}

			/* 3. í”Œë ˆì´ì–´ íƒ€ì¼ ë Œë”ë§ (ì „ì‚¬/ë§ˆë²•ì‚¬ í†µí•© 0,0 ê³ ì •) */
			int player_start_x = 0;
			int player_start_y = 0;

			SDL_Rect cp_s = { player_start_x + (player.anim_frame * 16), player_start_y + (player.dir * 16), ts, ts };
			SDL_Rect cp_d = { ox + 8 * ss, oy + 6 * ss, ss, ss };

			/* ë°˜ë“œì‹œ char_texë¥¼ ì‚¬ìš©í•´ì„œ ê·¸ë ¤ì•¼ ì£¼ì¸ê³µì´ ë³´ì—¬ì–´! */
			SDL_RenderCopy(renderer, char_tex, &cp_s, &cp_d);
		}

		/* [5. ì „íˆ¬ í™”ë©´ ë Œë”ë§] */
		else if (game_state == 3)
		{
			SET_COLOR(0, 0, 0);
			SDL_Rect b_bg = {0, 0, 800, 600};
			FILL_RECT(b_bg);

			if (current_monster == NULL) { game_state = 99; continue; }

			/* ğŸ’¡ ìˆ˜ì •ë¨: ì „íˆ¬í™”ë©´ì˜ ëª¬ìŠ¤í„° ì¢Œí‘œë„ ë§µê³¼ ì™„ë²½í•˜ê²Œ ë™ì¼í•˜ê²Œ ì„¸íŒ… ì™„ë£Œ! */
			int msx = 0; int msy = 0;
			if (is_boss) { msx = 96; msy = 64; }
			else if (difficulty == 0) { msx = 0; msy = 64; }
			else if (difficulty == 1) { msx = 144; msy = 0; }
			else { msx = 48; msy = 64; }

			SDL_Rect m_src = { msx, msy, 16, 16 };
			SDL_Rect m_dst = { 275, 120, 250, 250 };
			SDL_RenderCopy(renderer, char_tex, &m_src, &m_dst);

			/* ğŸ’¡ ìˆ˜ì •ë¨: ëª¬ìŠ¤í„° HP ì¶œë ¥ */
			char m_hp_str[32];
			sprintf(m_hp_str, "HP: %d/%d", current_monster->hp, current_monster->max_hp);
			render_text(renderer, m_hp_str, 340, 380, 255, 100, 100);

			draw_dw_window(renderer, 20, 20, 200, 260);
			render_text(renderer, "COMMAND", 50, 40, 255, 255, 255);
			char* b_menu[] = {"ATTACK", "SKILL", "ITEM", "DEFEND", "RUN"};
			for (int i = 0; i < 5; i++)
			{
				if (menu_index == i) render_text(renderer, ">", 35, 90 + (i * 35), 255, 255, 0);
				render_text(renderer, b_menu[i], 60, 90 + (i * 35), (menu_index == i ? 255 : 255), (menu_index == i ? 255 : 255), (menu_index == i ? 0 : 255));
			}

			/* ğŸ’¡ ìˆ˜ì •ë¨: í”Œë ˆì´ì–´ ìŠ¤í…Œì´í„°ìŠ¤ ì°½ í…ìŠ¤íŠ¸ ì¦ë°œ í•´ê²° (ë³€ìˆ˜ëª… ëª…í™•í™”) */
			draw_dw_window(renderer, 550, 20, 220, 200);
			render_text(renderer, "STATUS", 600, 40, 255, 255, 255);

			char stat_p[32];
			sprintf(stat_p, "HP:  %d", player.hp); 
			render_text(renderer, stat_p, 580, 90, 255, 255, 255);
			
			sprintf(stat_p, "MP:  %d", player.mp); 
			render_text(renderer, stat_p, 580, 130, 255, 255, 255);
			
			sprintf(stat_p, "ATK: %d", player.atk); 
			render_text(renderer, stat_p, 580, 170, 255, 255, 255);

			draw_dw_window(renderer, 100, 420, 600, 140);
			char msg_buf[128];
			sprintf(msg_buf, "%s APPEARED!", current_monster->name);
			render_text(renderer, msg_buf, 130, 460, 255, 255, 255);
		}

		/* [6. ê¸°íƒ€ ë©”ë‰´ ë° ê²Œì„ì˜¤ë²„] */
		else if (game_state >= 4 && game_state <= 6)
		{
			SET_COLOR(30, 10, 10);
			SDL_Rect bg = {0, 0, 800, 600};
			FILL_RECT(bg);

			if (game_state == 4) SET_COLOR(20, 40, 80);
			else if (game_state == 5) SET_COLOR(20, 80, 40);
			else SET_COLOR(60, 40, 20);

			SDL_Rect popup = {250, 200, 300, 200};
			FILL_RECT(popup);

			if (game_state == 4)
			{
				render_text(renderer, "--- SKILL ---", 285, 210, 255, 255, 255);
				for (int i = 0; i < 2; i++)
				{
					SDL_Rect opt = {300, 260 + (i * 60), 200, 40};
					if (menu_index == i) SET_COLOR(255, 255, 0);
					else SET_COLOR(150, 150, 150);
					FILL_RECT(opt);
					render_text(renderer, current_skills[i], 310, 270 + (i * 60), 0, 0, 0);
				}
			}
			else if (game_state == 5)
			{
				render_text(renderer, "--- ITEM ---", 290, 210, 255, 255, 255);
				char* i_list[] = {"1. HP POTION", "2. MP POTION"};
				for (int i = 0; i < 2; i++)
				{
					SDL_Rect opt = {300, 260 + (i * 60), 200, 40};
					if (menu_index == i) SET_COLOR(255, 255, 0);
					else SET_COLOR(150, 150, 150);
					FILL_RECT(opt);
					render_text(renderer, i_list[i], 310, 270 + (i * 60), 0, 0, 0);
				}
			}
			else if (game_state == 6)
			{
				render_text(renderer, "RUN AWAY?", 280, 230, 255, 255, 255);
				char* r_list[] = {"1. YES", "2. NO"};
				for (int i = 0; i < 2; i++)
				{
					SDL_Rect opt = {300, 280 + (i * 50), 200, 40};
					if (menu_index == i) SET_COLOR(255, 255, 0);
					else SET_COLOR(150, 150, 150);
					FILL_RECT(opt);
					render_text(renderer, r_list[i], 350, 290 + (i * 50), 0, 0, 0);
				}
			}
		}
		else if (game_state == 7)
		{
			SDL_Rect full_bg = {0, 0, 800, 600};
			if (player.hp <= 0) SET_COLOR(100, 0, 0);
			else SET_COLOR(0, 50, 100);
			FILL_RECT(full_bg);

			draw_dw_window(renderer, 150, 200, 500, 200);

			if (player.hp <= 0)
			{
				render_text(renderer, "YOU DIED...", 330, 240, 255, 50, 50);
			}
			else
			{
				render_text(renderer, "YOU WIN!", 340, 230, 50, 255, 50);
				render_text(renderer, diff_names[difficulty], 280, 280, 255, 255, 255);
				render_text(renderer, "STAGE CLEARED!", 310, 320, 255, 255, 0);
			}
			render_text(renderer, "PRESS ENTER TO RETURN", 230, 450, 255, 255, 255);
		}

		draw_scanlines(renderer, 800, 600);
		SDL_RenderPresent(renderer);
	}

	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	TTF_Quit();
	IMG_Quit();
	SDL_Quit();

	return 0;
}
